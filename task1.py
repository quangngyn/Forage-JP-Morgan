# -*- coding: utf-8 -*-
"""task1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GTSO7RbyT6Xu7n7iVM6J3Pg-Tp3orpEc
"""

import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime,timedelta
import numpy as np
from statsmodels.tsa.statespace.sarimax import *

data = pd.read_csv('Nat_Gas.csv')
dates = data["Dates"]
prices = data["Prices"]

pas_k = 12
valeurs_index_k = dates.index[::pas_k]

valeurs_x_k = dates[valeurs_index_k]
plt.plot(dates,prices)
plt.xticks(valeurs_x_k)

from statsmodels.tsa.stattools import adfuller

_, p, _, _, _, _ = adfuller(data["Prices"])
print(" p-value is: ", round(p, 3))

"""Our data are non stationnary. We have to make them stationnary to apply a SARIMA model."""

data_diff_12 = data["Prices"] - data["Prices"].shift(12)
data_diff_12_1 = data_diff_12 - data_diff_12.shift(1)

m1 = SARIMAX(data["Prices"], order=(0,1,1), seasonal_order=(1,0,0,12))
res1 = m1.fit(disp=False)
print(res1.summary())

from matplotlib import pprint
# pr√©diction et intervalles de confiance
y_pred = res1.get_forecast(12)
x_pred = y_pred.predicted_mean

print(x_pred)
plt.plot(x_pred)

dates_iso8601_liste = []

from datetime import datetime

def convertir_en_iso8601(date_str):
    date_obj = datetime.strptime(date_str, '%m/%d/%y')


    date_iso8601 = date_obj.strftime('%Y-%m-%d')

    return date_iso8601

for date in dates:
    date_iso8601 = convertir_en_iso8601(date)
    dates_iso8601_liste.append(date_iso8601)
data_iso = data
data_iso["Dates"] = dates_iso8601_liste

"""We can now make our function which will predict or estimate the price of gas."""

def estimate(date) :
  date1 = datetime.strptime(date, '%Y-%m-%d')
  date_limit = datetime.strptime('2024-9-30', '%Y-%m-%d')
  if date1 <= date_limit:
    #We will suppose that during a month the increase or decrease of price will be linear

    #We first extract the value of the month before and this month

    if date1.month < 9 :
      date_1 = str(date1.year)+"-"+str(0)+str(date1.month)
      value1 = data_iso.query('Dates.str.startswith(@date_1)')['Prices']
      next_month = date1 + timedelta(20)    #All the value are at the end of month so we just need to add >1 day to get the next month
      date_2 = str(next_month.year)+"-"+str(0)+str(next_month.month)
      value2 = data_iso.query('Dates.str.startswith(@date_2)')['Prices']
    elif date1.month == 9 :
      date_1 = str(date1.year)+"-"+str(0)+str(date1.month)
      value1 = data_iso.query('Dates.str.startswith(@date_1)')['Prices']
      next_month = date1 + timedelta(20)    #All the value are at the end of month so we just need to add >1 day to get the next month
      date_2 = str(next_month.year)+"-"+str(next_month.month)
      value2 = data_iso.query('Dates.str.startswith(@date_2)')['Prices']
    else :
      date_1 = str(date1.year)+"-"+str(date1.month)
      value1 = data_iso.query('Dates.str.startswith(@date_1)')['Prices']

      next_month = date1 + timedelta(20)    #All the value are at the end of month so we just need to add >1 day to get the next month
      date_2 = str(next_month.year)+"-"+str(next_month.month)
      value2 = data_iso.query('Dates.str.startswith(@date_2)')['Prices']
    #We do a linear approximation
    day = date1.day

    #two case if it is february or not
    if date1.month == 2 :
      if date1.year%4 == 0 :
        linear = day*(value2.tolist()[0]-value1.tolist()[0])/29+value1.tolist()[0]
        return(linear)
      else :
        linear = day*(value2.tolist()[0]-value1.tolist()[0])/28+value1.tolist()[0]
        return(linear)
    else :

      linear = day*(value2.tolist()[0]-value1.tolist()[0])/30+value1.tolist()[0]
      return(linear)

  else:
    m1 = SARIMAX(data["Prices"], order=(0,1,1), seasonal_order=(1,0,0,12))
    res1 = m1.fit(disp=False)
    diff = date1.year - 2024 + 1
    y_pred = res1.get_forecast(diff * 12)
    distance_time = (date1.year - 2024)*12 + date1.month
    x_pred = y_pred.predicted_mean
    day = date1.day
    if date1.month == 2 :
      if date1.year%4 == 0 :
        linear = day*(x_pred[distance_time+48]-x_pred[distance_time+47])/29+x_pred[distance_time+47]
        return(linear)
      else :
        linear = day*(x_pred[distance_time+48]-x_pred[distance_time+47])/28+x_pred[distance_time+47]
        return(linear)
    else :

      linear = day*(x_pred[distance_time+48]-x_pred[distance_time+47])/30+x_pred[distance_time+47]
      return(linear)


#We can now predict by using this function with as input "Date" we want.
estimate("2025-02-20")